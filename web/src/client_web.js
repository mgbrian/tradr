// gRPC Web client for the TradingService

// NOTE: The client class is attached to window.TradingWebClient for ease of use.

/* eslint-disable no-undef */
const svc = require("./protos/service_grpc_web_pb.js");
const messages = require("./protos/service_pb.js");

/**
 * Convert an OrderRecord to a plain JS object.
 * @param {messages.OrderRecord} msg
 * @returns {{order_id:number, broker_order_id:number, asset_class:string, symbol:string, side:string, quantity:number, status:string, avg_price:number, filled_qty:number, message:string}}
 */
function orderRecordToObj(msg) {
  if (!msg) return {};
  return {
    order_id: Number(msg.getOrderId()),
    broker_order_id: Number(msg.getBrokerOrderId()),
    asset_class: msg.getAssetClass(),
    symbol: msg.getSymbol(),
    side: msg.getSide(),
    quantity: Number(msg.getQuantity()),
    status: msg.getStatus(),
    avg_price: Number(msg.getAvgPrice()),
    filled_qty: Number(msg.getFilledQty()),
    message: msg.getMessage(),
  };
}

/**
 * Convert a FillRecord to a plain JS object.
 * @param {messages.FillRecord} msg
 * @returns {{fill_id:number, order_id:number, exec_id:string, price:number, filled_qty:number, symbol:string, side:string, time:string, broker_order_id:number}}
 */
function fillRecordToObj(msg) {
  if (!msg) return {};
  return {
    fill_id: Number(msg.getFillId()),
    order_id: Number(msg.getOrderId()),
    exec_id: msg.getExecId(),
    price: Number(msg.getPrice()),
    filled_qty: Number(msg.getFilledQty()),
    symbol: msg.getSymbol(),
    side: msg.getSide(),
    time: msg.getTime(),
    broker_order_id: Number(msg.getBrokerOrderId()),
  };
}

/**
 * Convert a PositionRecord to a plain JS object.
 * @param {messages.PositionRecord} msg
 * @returns {{account:string, symbol:string, sec_type:string, exchange:string, con_id:number, position:number, avg_cost:number}}
 */
function positionRecordToObj(msg) {
  if (!msg) return {};
  return {
    account: msg.getAccount(),
    symbol: msg.getSymbol(),
    sec_type: msg.getSecType(),
    exchange: msg.getExchange(),
    con_id: Number(msg.getConId()),
    position: Number(msg.getPosition()),
    avg_cost: Number(msg.getAvgCost()),
  };
}

/**
 * Convert an AccountValueRecord to a plain JS object.
 * @param {messages.AccountValueRecord} msg
 * @returns {{account:string, tag:string, currency:string, value:string}}
 */
function accountValueRecordToObj(msg) {
  if (!msg) return {};
  return {
    account: msg.getAccount(),
    tag: msg.getTag(),
    currency: msg.getCurrency(),
    value: msg.getValue(),
  };
}

/**
 * gRPC-web client for TradingService that returns plain JS objects.
 */
class TradingWebClient {
  /**
   * Construct a TradingWebClient.
   * @param {string} baseUrl - The grpc-web HTTP endpoint (proxy) base URL, e.g. "http://localhost:8080".
   * @param {{metadata?: Object, format?: 'text'|'binary'}} [opts]
   *   metadata: Optional default metadata (headers) per call.
   *   format: grpcweb mode. Usually 'text' for grpcwebproxy/Envoy (default 'text').
   */
  constructor(baseUrl, opts) {
    this.baseUrl = (baseUrl || "").replace(/\/+$/, "");
    this.metadata = (opts && opts.metadata) || {};
    const format = (opts && opts.format) || "text"; // 'text' (grpcwebtext) or 'binary'
    // Promise client generated by protoc-gen-grpc-web
    this.client = new svc.TradingServicePromiseClient(this.baseUrl, null, {
      format, // maps to mode=grpcwebtext or grpcweb when generated
    });
  }

  // --- Orders ---

  /**
   * Place a stock order.
   *
   * Supports market, limit, and stop orders.
   * - orderType: "MKT" (default) | "LMT" | "STP"
   * - price: used for LMT/STP (proto field is `price`)
   * - tif: "DAY" (default) | "GTC"
   *
   * @param {string} symbol - e.g. "AAPL".
   * @param {"BUY"|"SELL"|"SHORT"|"COVER"|string} side
   * @param {number} quantity
   * @param {"MKT"|"LMT"|"STP"|string} [orderType="MKT"]
   * @param {number} [price] - Only set when using LMT/STP (kept optional for proto semantics).
   * @param {"DAY"|"GTC"|string} [tif="DAY"]
   * @returns {Promise<{order_id:number, broker_order_id:number, status:string, message:string}>}
   */
  async PlaceStockOrder(symbol, side, quantity, orderType = "MKT", price /* optional */, tif = "DAY") {
    const req = new messages.PlaceStockOrderRequest();
    req.setSymbol(symbol);
    req.setSide(side);
    req.setQuantity(quantity);

    // Optional fields: set only if provided to preserve proto optional semantics.
    if (orderType) req.setOrderType(orderType);
    if (tif) req.setTif(tif);
    if (price !== undefined && price !== null) req.setPrice(Number(price));

    const resp = await this.client.placeStockOrder(req, this.metadata);
    return {
      order_id: Number(resp.getOrderId()),
      broker_order_id: Number(resp.getBrokerOrderId()),
      status: resp.getStatus(),
      message: resp.getMessage(),
    };
  }

  /**
   * Place an option order.
   *
   * Supports market, limit, and stop orders.
   * - orderType: "MKT" (default) | "LMT" | "STP"
   * - price: used for LMT/STP (proto field is `price`)
   * - tif: "DAY" (default) | "GTC"
   *
   * @param {string} symbol - Underlying ticker.
   * @param {string} expiry - YYYYMMDD.
   * @param {number} strike
   * @param {"C"|"P"|string} right
   * @param {"BUY"|"SELL"|string} side
   * @param {number} quantity - contracts
   * @param {"MKT"|"LMT"|"STP"|string} [orderType="MKT"]
   * @param {number} [price] - Only set when using LMT/STP (kept optional for proto semantics).
   * @param {"DAY"|"GTC"|string} [tif="DAY"]
   * @returns {Promise<{order_id:number, broker_order_id:number, status:string, message:string}>}
   */
  async PlaceOptionOrder(
    symbol,
    expiry,
    strike,
    right,
    side,
    quantity,
    orderType = "MKT",
    price /* optional */,
    tif = "DAY"
  ) {
    const req = new messages.PlaceOptionOrderRequest();
    req.setSymbol(symbol);
    req.setExpiry(expiry);
    req.setStrike(strike);
    req.setRight(right);
    req.setSide(side);
    req.setQuantity(quantity);

    if (orderType) req.setOrderType(orderType);
    if (tif) req.setTif(tif);
    if (price !== undefined && price !== null) req.setPrice(Number(price));

    const resp = await this.client.placeOptionOrder(req, this.metadata);
    return {
      order_id: Number(resp.getOrderId()),
      broker_order_id: Number(resp.getBrokerOrderId()),
      status: resp.getStatus(),
      message: resp.getMessage(),
    };
  }

  /**
   * Request cancellation of an existing order by internal id.
   * @param {number} orderId
   * @returns {Promise<{ok:boolean, status:string, message:string}>}
   */
  async CancelOrder(orderId) {
    const req = new messages.CancelOrderRequest();
    req.setOrderId(Number(orderId));
    const resp = await this.client.cancelOrder(req, this.metadata);
    return {
      ok: !!resp.getOk(),
      status: resp.getStatus(),
      message: resp.getMessage(),
    };
  }

  /**
   * Fetch a single order by internal id.
   * @param {number} orderId
   * @returns {Promise<Object>} - Plain order object.
   */
  async GetOrder(orderId) {
    const req = new messages.GetOrderRequest();
    req.setOrderId(orderId); // field: order_id -> setOrderId
    const resp = await this.client.getOrder(req, this.metadata);
    return orderRecordToObj(resp);
  }

  /**
   * List recent orders.
   * @param {number} [limit] - Max rows.
   * @returns {Promise<Object[]>}
   */
  async ListOrders(limit) {
    const req = new messages.ListOrdersRequest();
    if (typeof limit === "number") req.setLimit(limit);
    const resp = await this.client.listOrders(req, this.metadata);
    const list = resp.getOrdersList();
    return list.map(orderRecordToObj);
  }

  /**
   * List fills, optionally for a single order.
   * @param {number} [orderId]
   * @param {number} [limit]
   * @returns {Promise<Object[]>}
   */
  async ListFills(orderId, limit) {
    const req = new messages.ListFillsRequest();
    if (typeof orderId === "number") req.setOrderId(orderId); // field: order_id -> setOrderId
    if (typeof limit === "number") req.setLimit(limit);
    const resp = await this.client.listFills(req, this.metadata);
    const list = resp.getFillsList();
    return list.map(fillRecordToObj);
  }

  // --- Positions & Account Values ---

  /**
   * Get current positions snapshot.
   * @returns {Promise<Object[]>}
   */
  async GetPositions() {
    const req = new messages.GetPositionsRequest();
    const resp = await this.client.getPositions(req, this.metadata);
    const list = resp.getPositionsList();
    return list.map(positionRecordToObj);
  }

  /**
   * Get current account values snapshot.
   * @returns {Promise<Object[]>}
   */
  async GetAccountValues() {
    const req = new messages.GetAccountValuesRequest();
    const resp = await this.client.getAccountValues(req, this.metadata);
    const list = resp.getAccountValuesList();
    return list.map(accountValueRecordToObj);
  }
}

window.TradingWebClient = TradingWebClient;
